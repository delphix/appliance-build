#!/bin/bash -ex
#
# Copyright 2018 Delphix
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# This script is intended to be used as part of Delphix's build process.
# It's role is to convert the "binary" directory generated by live-build,
# into a bootable disk image, running ZFS as the root filesystem (whose
# contents are that of the "binary" directory).
#

#
# When running in Travis CI, we cannot expect this script to be running
# on a host that has the ZFS kernel modules installed *and* for those
# kernel modules to be of the version that we expect. Thus, when we
# detect we're running in Travis, we avoid creating the VM artifacts
# that depend on ZFS.
#
if [[ -n "$CI" && -n "$TRAVIS" ]]; then
	exit 0
fi

#
# We want to use different sized rpool depending on if we're building a
# disk image meant for internal use, or external (i.e. customer) use.
#
case "$APPLIANCE_VARIANT" in
internal-*)
	RAW_DISK_SIZE_GB=70
	;;
external-*)
	RAW_DISK_SIZE_GB=127
	;;
*)
	echo "Invalid variant specified: '$APPLIANCE_VARIANT'" 1>&2
	exit 1
	;;
esac

RPOOL_REAL_NAME="rpool"
RPOOL_TEMP_NAME="rpool-$$"

rm -f "$APPLIANCE_VARIANT.img"
truncate -s "${RAW_DISK_SIZE_GB}G" "$APPLIANCE_VARIANT.img"
sgdisk --zap-all "$APPLIANCE_VARIANT.img"

#
# Here we're creating the boot partition. When installing grub, this
# partition will be used and automatically detected by "grub-install"
# based on the partitions typecode. This partition is required since we're
# partitioning using GPT; if we used MBR, an explicit boot partition
# wouldn't be required.
#
sgdisk "$APPLIANCE_VARIANT.img" \
	--set-alignment=1 --new=2:34:2047 --typecode=2:EF02

#
# Now we create the partition that we'll use for the zpool that will be
# used for the root pool. We use a generic typecode for this partition
# that simply maps to "Linux filesystem". The typecode here is simply
# cosmetic, as there's nothing that relies on it being set.
#
sgdisk "$APPLIANCE_VARIANT.img" --new=1:: --typecode=1:8300

#
# This is done simply for debugging and/or diagnostic purposes. When
# running this script via automation, it can be helpful to capture the
# state of the disk image's partition table in the logs.
#
sgdisk "$APPLIANCE_VARIANT.img" --print

#
# We expect kpartx's output to resemble the following:
#
#     add map loop0p1 (253:0): 0 33552351 linear 7:0 2048
#     add map loop0p2 (253:1): 0 2014 linear 7:0 34
#
# We then manipulate this output, such that we can return only the
# loopback device name, which would be "loop0" in this example. From that,
# consumers can easily build the names of the individual partitions as
# needed.
#
LOOPNAME=$(kpartx -asv "$APPLIANCE_VARIANT.img" |
	head -n1 |
	awk '{ print $3 }' |
	sed 's/^\(loop[0-9]\+\)p[0-9]\+$/\1/')

#
# Initialize the root pool using the partition we previously created.
#
mkdir -p "/mnt/$RPOOL_TEMP_NAME"
zpool create \
	-O canmount=off -O mountpoint=none -R "/mnt/$RPOOL_TEMP_NAME" \
	-t "$RPOOL_TEMP_NAME" "$RPOOL_REAL_NAME" \
	"/dev/mapper/${LOOPNAME}p1"

#
# Initialize the root pool's datasets.
#
zfs create -o canmount=off -o mountpoint=none "$RPOOL_TEMP_NAME/ROOT"
zfs create -o canmount=noauto -o mountpoint=/ "$RPOOL_TEMP_NAME/ROOT/ubuntu"
zfs mount "$RPOOL_TEMP_NAME/ROOT/ubuntu"

#
# Populate the root filesystem with the contents of the "binary" directory
# that (we assume) was previously generated by live-build.
#
rsync --info=stats3 -Wa binary/* "/mnt/$RPOOL_TEMP_NAME/"

#
# Now we need to install the bootloader. In order to do that, we'll chroot
# into the newly populated root filesystem, so that we use the grub-install
# and update-grub binaries installed in that filesystem.  Additionally, we
# need to have the /dev, /proc, and /sys mountpoints present in that chroot
# environment, which is why we bind mount here.
#
mount --rbind /dev "/mnt/$RPOOL_TEMP_NAME/dev"
mount --rbind /proc "/mnt/$RPOOL_TEMP_NAME/proc"
mount --rbind /sys "/mnt/$RPOOL_TEMP_NAME/sys"

chroot "/mnt/$RPOOL_TEMP_NAME" grub-install "/dev/$LOOPNAME"
chroot "/mnt/$RPOOL_TEMP_NAME" update-grub

#
# This will unmount the bind mounts created earlier. This is required
# because we used "--rbind" when mounting directories like /sys and
# /proc, so we need to unmount any of those recursively mounted
# mountpoints; a simple "umount /sys" will fail with EBUSY.
#
mount | grep -v zfs | tac | awk "/\/mnt\/$RPOOL_TEMP_NAME/ {print \$3}" |
	xargs -i{} umount -lf {}

zfs umount "$RPOOL_TEMP_NAME/ROOT/ubuntu"
zpool export "$RPOOL_TEMP_NAME"
kpartx -d "$APPLIANCE_VARIANT.img"
